原型模式：
    通过一个原型对象克隆出多个一模一样的对象。

    概述：
        原型模式(Prototype Pattern):使用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。

        工作原理：将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己
            来实现创建过程。由于在软件系统中我们经常会遇到需要创建多个相同或者相似对象的情况，因此原型
            模式在真实开发中的使用频率还是非常高的。原型模式是一种"另类"的创建型模式，创建克隆对象的工
            厂就是原型类自身，工厂方法由克隆方法来实现。

        注意：通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进
            行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的。通过不同的方式修改可以得到
            一系类相似但不完全相同的对象。

        三个角色：
            Prototype(抽象原型类):它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类
                也可以是接口，甚至还可以是具体的实现类。（现用Java提供的Cloneable接口）
            ConcretePrototype(具体原型类):它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己
                的一个克隆对象。
            Client(客户类):让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或
                通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象，
                由于客户类基于抽象类编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性。

        在Java语言中常见的两种克隆实现方式：
            1、通用实现方法（ConcretePrototype）
                通用的克隆实现方法是在具体原型类的克隆方法中实例化一个与自身类型相同的对象并将其返回，
                并将相关参数传入新创建的对象中，保证它们的成员属性相同。
            2、Java语言提供的clone()方法
                所有的Java类都继承自java.lang.Object。Object提供一个clone()方法，可以将一个Java
                对象复制一份。
                注意：实现克隆的Java类必须实现一个标识接口Cloneable,表示这个Java类支持被复制。


        一般而言，Java语言中的clone()方法满足：
            ①对任何对象o，都有o.clone()!=o，即克隆对象与原型对象不是同一个对象
            ②对任何对象o，都有o.clone().getClass() == o.getClass(),即克隆对象与原型对象的类型一样。
            ③如果对象o的equals()方法定义恰当，那么o.clone().equals(o)应该成立(在某种程度上来说克隆对
              象和原型对象是一样的)

        为了获取对象的一份拷贝，我们可以直接利用Object类的clone()方法，具体步骤：
            ①在派生类中覆盖基类的clone()方法，并声明public
            ②在派生类的clone()方法中，调用super.clone()
            ③派生类需要实现Cloneable接口
            注：Object类相当于抽象原型类，所有实现了Cloneable接口的类相当于具体原型类

        两种不同的克隆方法：
            浅克隆（ShallowClone）:
                在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型
                对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型
                对象和克隆对象的成员变量指向相同的内存地址。简单的说，在浅克隆中，当对象被复
                制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员变量没有被复制。
            深克隆（DeepClone）:
                如果需要实现深克隆，可以通过序列化(Serialization)等方式来实现。序列化就是将
                对象写到流的过程，写到流中的对象是原有对象的一个拷贝，而原对象仍然存在于内存中。
                通过序列化实现的拷贝不仅可以复制对象本身，而且可以复制其引用的成员变量，因此通过
                序列化将对象写到一个流中，再将流里将其读出来，可以实现深克隆。
            区别：浅克隆和深克隆主要的区别在于是否支持引用类型变量的复制


        原型管理器的引入和实现：
            原型管理器(Prototype Manager)是将多个原型对象存储在一个集合中供客户端使用，它是一个
            专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象，如果需要某个原型对象的一个
            克隆，可以通过复制集合中对应的原型对象来获得。在原型管理器中针对抽象原型类进行编程，以
            便扩展。


        总结：
            原型模式主要优点：
                ①当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有
                  实例可以提高新实例的创建效率。
                ②扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而
                  将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有影响。
                ③原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级
                  结构，而原型模式不需要这样，原型模式中产品复制是通过封装在原型类中的克隆方法实现的，无
                  需专门的工厂类来创建产品。
                ④可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便
                  在需要使用的时候使用(如恢复到某一历史状态)，可辅助实现撤销操作。

            主要缺点：
                ①需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类内部，当对已有的类进行改造时，需
                   要修改源代码，违背了"开闭原则"。
                ②在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，
                   每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。

            适用场景：
                ①创建新对象成本较大，新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以
                  对成员变量稍作修改。
                ②如果系统要保存对象的状态，而且对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模
                  式配合备忘录模式来实现。
                ③需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通
                  过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。